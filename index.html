<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>라이브 얼굴 점수 (Beta)</title>
  <style>
    :root{color-scheme:dark light}
    body{margin:0;font-family:system-ui, sans-serif;background:#0b0b0c;color:#fff}
    .wrap{min-height:100dvh;display:grid;place-items:center;padding:16px}
    .stage{position:relative;width:min(92vw,960px);aspect-ratio:16/9}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;border-radius:16px}
    .hud{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,.45);backdrop-filter:blur(8px);
         padding:10px 14px;border-radius:999px;font-size:14px}
    .tag{margin-left:8px;padding:2px 8px;background:#1d1f22;border-radius:999px;opacity:.9}
    .warn{position:absolute;inset:auto 12px 12px auto;background:#2b1a1a;color:#ffd7d7;padding:8px 10px;border-radius:8px;display:none}
    .top{position:absolute;left:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap}
    .pill{font-size:12px;padding:4px 8px;background:rgba(0,0,0,.45);border-radius:999px}
    a{color:#9df}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <video id="cam" autoplay playsinline muted></video>
      <canvas id="ov"></canvas>
      <div class="top">
        <span class="pill">Allow camera permission</span>
        <span class="pill">Tip: 정면·밝게·화면 1/6 이상</span>
      </div>
      <div class="hud">
        Score: <strong id="score">—</strong>
        <span class="tag" id="qual">quality: —</span>
      </div>
      <div class="warn" id="warn">카메라 접근 실패. 브라우저 권한/HTTPS 확인.</div>
    </div>
    <p style="opacity:.7;font-size:13px;">
      Powered by <a href="https://github.com/google/mediapipe" target="_blank" rel="noreferrer">MediaPipe Tasks Vision</a>. 
      모든 추론은 브라우저에서만 수행(서버 전송 없음).
    </p>
  </div>

  <!-- MediaPipe Tasks Vision (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest"></script>
  <script>
  (async () => {
    const video = document.getElementById('cam');
    const canvas = document.getElementById('ov');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const scoreEl = document.getElementById('score');
    const qualEl  = document.getElementById('qual');
    const warnEl  = document.getElementById('warn');

    // 1) 카메라
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      warnEl.style.display = 'block';
      console.error('getUserMedia error', e);
      return;
    }

    // 크기 동기화
    function fit() {
      canvas.width  = video.videoWidth  || 1280;
      canvas.height = video.videoHeight || 720;
    }
    if (video.readyState >= 2) fit(); else video.addEventListener('loadeddata', fit);

    // 2) MediaPipe Face Landmarker 로드
    const { FaceLandmarker, FilesetResolver, DrawingUtils } = window;
    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
    );
    const faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
      baseOptions: {
        // 구글 호스팅 모델 (CORS 허용)
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      outputFaceBlendshapes: false
    });

    // 3) 점수 계산 보조함수
    function roiStats(x, y, w, h) {
      const W = canvas.width, H = canvas.height;
      const rx = Math.max(0, Math.floor(x));
      const ry = Math.max(0, Math.floor(y));
      const rw = Math.min(W - rx, Math.floor(w));
      const rh = Math.min(H - ry, Math.floor(h));
      if (rw <= 0 || rh <= 0) return { bright:0, sharp:0, area:0 };

      const img = ctx.getImageData(rx, ry, rw, rh);
      const d = img.data;
      let sum=0;
      const gray = new Uint8ClampedArray(rw*rh);
      for (let i=0, gi=0; i<d.length; i+=4, gi++) {
        const L = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
        gray[gi] = L; sum += L;
      }
      const bright = sum / gray.length; // 0..255

      // 간단 라플라시안 샤프니스
      let lap = 0, cnt = 0;
      for (let yy=1; yy<rh-1; yy++){
        for (let xx=1; xx<rw-1; xx++){
          const i = yy*rw + xx;
          const val = 4*gray[i] - gray[i-1] - gray[i+1] - gray[i-rw] - gray[i+rw];
          lap += val*val; cnt++;
        }
      }
      const sharp = Math.sqrt(lap/Math.max(1,cnt));
      const area  = (rw*rh)/(W*H);
      return { bright, sharp, area };
    }

    // 4) 루프
    let ema = null, alpha = 0.2;
    const drawer = new DrawingUtils(ctx);

    function qualityGate(box, yawPitchRollScore, area) {
      // 중앙/크기/포즈(정면도) 간단 체크
      const W = canvas.width, H = canvas.height;
      const cx = box.x + box.width/2;
      const centered = Math.abs(cx - W/2)/(W/2); // 0(중앙)~1(모서리)
      const areaOk = area > 0.06;       // 얼굴이 프레임의 6% 이상
      const centerOk = centered < 0.6;  // 너무 몰리지 않음
      const poseOk = yawPitchRollScore > 0.6;
      return areaOk && centerOk && poseOk;
    }

    function poseScore(landmarks) {
      // 간단 정면도 근사: 양/음 뺨-코 길이 균형 등으로 0~1
      if (!landmarks || landmarks.length === 0) return 0;
      const lm = landmarks[0]; // 첫 얼굴
      // 왼/오 눈 구석, 코 끝, 귀 근처 등을 대략 사용
      // (정확한 포즈는 solvePnP가 좋지만 MVP는 근사)
      const leftEye  = lm[33],  rightEye = lm[263], nose = lm[1];
      if (!leftEye || !rightEye || !nose) return 0.5;
      const dx = Math.abs(leftEye.x - rightEye.x);
      const yn = Math.abs(leftEye.y - rightEye.y);
      const horiz = Math.min(1, dx*4);            // 가로폭 넓으면 가점
      const level = Math.max(0, 1 - yn*20);       // 양쪽 눈 높이 차 적을수록 가점
      return Math.max(0, Math.min(1, 0.6*horiz + 0.4*level));
    }

    let lastTs = -1;
    async function frame(t) {
      const W = canvas.width, H = canvas.height;
      ctx.drawImage(video, 0, 0, W, H);

      const res = await faceLandmarker.detectForVideo(video, t ?? performance.now());
      if (res && res.faceLandmarks && res.faceLandmarks.length) {
        // 대략 박스 만들기
        const pts = res.faceLandmarks[0];
        let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
        for (const p of pts) {
          const x = p.x*W, y = p.y*H;
          if (x<minX) minX=x; if (x>maxX) maxX=x;
          if (y<minY) minY=y; if (y>maxY) maxY=y;
        }
        const box = { x:minX, y:minY, width:maxX-minX, height:maxY-minY };

        // 시각화
        ctx.lineWidth = 3; ctx.strokeStyle = '#00ffd0';
        ctx.strokeRect(box.x, box.y, box.width, box.height);

        const { bright, sharp, area } = roiStats(box.x, box.y, box.width, box.height);
        const pose = poseScore(res.faceLandmarks);

        // 정규화 스코어 (간단 휴리스틱 0~100)
        const bScore = Math.max(0, Math.min(100, (bright - 60) * (100/140))); // ~60~200 가정
        const sScore = Math.max(0, Math.min(100, (sharp  - 4)  * 12));
        const pScore = pose * 100;

        let raw = 0.35*bScore + 0.35*sScore + 0.30*pScore;

        const ok = qualityGate(box, pose, area);
        if (!ok) raw *= 0.6;

        ema = (ema==null) ? raw : (alpha*raw + (1-alpha)*ema);
        const final = Math.round(Math.max(0, Math.min(100, ema)));

        scoreEl.textContent = final;
        qualEl.textContent  = `quality: ${ok ? 'ok' : 'low'}`;
      } else {
        scoreEl.textContent = '—';
        qualEl.textContent  = 'quality: —';
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
