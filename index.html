<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Face Score (Beta)</title>
  <style>
    :root{color-scheme:dark light}
    body{margin:0;font-family:system-ui, sans-serif;background:#0b0b0c;color:#fff}
    .wrap{min-height:100dvh;display:grid;place-items:center;padding:16px}
    .stage{position:relative;width:min(92vw,960px);aspect-ratio:16/9}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;border-radius:16px}
    .hud{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,.45);backdrop-filter:blur(8px);
         padding:10px 14px;border-radius:999px;font-size:14px}
    .pill{position:absolute;left:12px;top:12px;font-size:12px;padding:6px 10px;background:rgba(0,0,0,.45);border-radius:999px}
    .debug{position:absolute;right:12px;top:12px;font:12px ui-monospace,monospace;background:rgba(0,0,0,.45);
           border-radius:10px;padding:8px 10px;max-width:min(60ch,40vw);white-space:pre-wrap}
    .warn{position:absolute;right:12px;bottom:12px;background:#2b1a1a;color:#ffd7d7;padding:8px 10px;border-radius:8px;display:none}
    .tag{margin-left:8px;padding:2px 8px;background:#1d1f22;border-radius:999px;opacity:.9}
    a{color:#9df}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <video id="cam" autoplay playsinline muted></video>
      <canvas id="ov"></canvas>
      <div class="pill">Tip: 정면·밝게·화면 1/6 이상</div>
      <div class="hud">Score: <strong id="score">—</strong> <span class="tag" id="qual">quality: —</span></div>
      <div class="debug" id="debug">init…</div>
      <div class="warn" id="warn">카메라/모델 로드 실패. 콘솔(F12) 확인.</div>
    </div>
    <p style="opacity:.7;font-size:13px">
      Powered by MediaPipe Tasks Vision. 모든 추론은 브라우저에서 수행(서버 전송 없음).
    </p>
  </div>

  <!-- ✅ 버전 고정 (예: 0.10.17). 최신으로 바꾸고 싶으면 숫자만 올려. -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17"></script>
  <script>
  (async () => {
    const video = document.getElementById('cam');
    const canvas = document.getElementById('ov');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const scoreEl = document.getElementById('score');
    const qualEl  = document.getElementById('qual');
    const warnEl  = document.getElementById('warn');
    const dbg     = document.getElementById('debug');

    function log(s){ dbg.textContent = s; }

    // 1) 카메라
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      warnEl.style.display = 'block';
      log('getUserMedia error: '+e);
      console.error(e);
      return;
    }

    function syncCanvasSize(){
      const W = video.videoWidth || 1280;
      const H = video.videoHeight || 720;
      canvas.width = W; canvas.height = H;
    }
    if (video.readyState >= 2) syncCanvasSize();
    else video.addEventListener('loadeddata', syncCanvasSize);

    // 2) MediaPipe Face Landmarker 로드
    const { FaceLandmarker, FilesetResolver } = window;
    if (!FaceLandmarker || !FilesetResolver) {
      warnEl.style.display = 'block';
      log('MediaPipe Tasks Vision not loaded (CDN 차단?)');
      return;
    }

    log('loading wasm/files…');
    const vision = await FilesetResolver.forVisionTasks(
      // ✅ WASM 경로(버전 맞춤)
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm"
    );

    let faceLandmarker = null;
    try {
      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          // ✅ 구글 호스팅 모델 (CORS 허용)
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
        },
        runningMode: "VIDEO",    // LIVE_STREAM도 가능하지만 VIDEO가 호환성 좋음
        numFaces: 1,
        outputFaceBlendshapes: false
      });
    } catch (e) {
      warnEl.style.display = 'block';
      log('FaceLandmarker create error: '+e);
      console.error(e);
      return;
    }
    log('loaded. detecting…');

    // 3) 점수 함수들
    function roiStats(x, y, w, h){
      const W = canvas.width, H = canvas.height;
      const rx = Math.max(0, Math.floor(x)), ry = Math.max(0, Math.floor(y));
      const rw = Math.min(W - rx, Math.floor(w)), rh = Math.min(H - ry, Math.floor(h));
      if (rw<=0 || rh<=0) return { bright:0, sharp:0, area:0 };

      const img = ctx.getImageData(rx, ry, rw, rh).data;
      const gray = new Uint8ClampedArray(rw*rh);
      let sum=0;
      for (let i=0, gi=0; i<img.length; i+=4, gi++){
        const L = 0.2126*img[i] + 0.7152*img[i+1] + 0.0722*img[i+2];
        gray[gi]=L; sum+=L;
      }
      const bright = sum/gray.length; // 0..255

      // 라플라시안 샤프니스
      let acc=0, cnt=0;
      for (let yy=1; yy<rh-1; yy++){
        for (let xx=1; xx<rw-1; xx++){
          const i = yy*rw + xx;
          const v = 4*gray[i] - gray[i-1] - gray[i+1] - gray[i-rw] - gray[i+rw];
          acc += v*v; cnt++;
        }
      }
      const sharp = Math.sqrt(acc/Math.max(1,cnt));
      const area = (rw*rh)/(W*H);
      return { bright, sharp, area };
    }

    function poseScore(lm){
      if (!lm || lm.length===0) return 0;
      const pts = lm[0];
      const L = pts[33], R = pts[263], N = pts[1];
      if (!L || !R || !N) return 0.5;
      const dx = Math.abs(L.x - R.x);
      const dy = Math.abs(L.y - R.y);
      const horiz = Math.min(1, dx*4);
      const level = Math.max(0, 1 - dy*20);
      return Math.max(0, Math.min(1, 0.6*horiz + 0.4*level));
    }

    function qualityGate(box, pose, area){
      const W = canvas.width;
      const cx = box.x + box.width/2;
      const centered = Math.abs(cx - W/2)/(W/2);
      return area > 0.06 && centered < 0.6 && pose > 0.6;
    }

    let ema=null, alpha=0.25;
    let lastLogTime=0;

    async function tick(ts){
      const W = canvas.width, H = canvas.height;
      ctx.drawImage(video, 0, 0, W, H);

      const res = faceLandmarker.detectForVideo(video, ts || performance.now());
      // 최신 버전에선 동기/비동기 혼재 없이 동기 반환(예전엔 Promise). 방어적 처리:
      const out = (typeof res?.then === 'function') ? await res : res;

      if (out && out.faceLandmarks && out.faceLandmarks.length){
        const pts = out.faceLandmarks[0];
        // 박스 얻기(정규화 → 픽셀)
        let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
        for (const p of pts){
          const x = p.x*W, y = p.y*H;
          if (x<minX) minX=x; if (x>maxX) maxX=x;
          if (y<minY) minY=y; if (y>maxY) maxY=y;
        }
        const box = { x:minX, y:minY, width:maxX-minX, height:maxY-minY };
        ctx.lineWidth=3; ctx.strokeStyle='#00ffd0';
        ctx.strokeRect(box.x, box.y, box.width, box.height);

        const { bright, sharp, area } = roiStats(box.x, box.y, box.width, box.height);
        const p = poseScore(out.faceLandmarks);

        const bScore = Math.max(0, Math.min(100, (bright - 60) * (100/140)));
        const sScore = Math.max(0, Math.min(100, (sharp  - 4)  * 12));
        const pScore = Math.round(p*100);

        let raw = 0.35*bScore + 0.35*sScore + 0.30*pScore;
        const ok = qualityGate(box, p, area);
        if (!ok) raw *= 0.6;

        ema = (ema==null) ? raw : (alpha*raw + (1-alpha)*ema);
        const final = Math.round(Math.max(0, Math.min(100, ema)));

        scoreEl.textContent = final;
        qualEl.textContent  = `quality: ${ok ? 'ok' : 'low'}`;

        // 1초에 한 번 상태 요약
        if (!lastLogTime || ts - lastLogTime > 1000){
          log(`faces:1  bright:${bScore.toFixed(1)}  sharp:${sScore.toFixed(1)}  pose:${pScore}  area:${(area*100).toFixed(1)}%`);
          lastLogTime = ts;
        }
      } else {
        // 얼굴 없음 또는 landmarks 0 → 디버그 표시
        scoreEl.textContent = '—';
        qualEl.textContent  = 'quality: —';
        if (!lastLogTime || ts - lastLogTime > 1000){
          log('no face / no landmarks (모델·WASM·CDN·조명 확인)');
          lastLogTime = ts;
        }
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
